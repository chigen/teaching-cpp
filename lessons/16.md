### 二叉树(Binary tree)
二叉树是每个节点最多只有两个分支（即不存在分支度大于2的节点）的树结构

### 二叉搜索树(Binary search tree)
#### 性质：
- 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；
- 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；
- 任意节点的左、右子树也分别为二叉查找树；
- 其中，左子树中最大节点（前继）和右子树中的最小节点（后继）被称为继承者（successor）
#### 时间复杂度：
- 搜索：O(logn)
- 插入：O(logn)
- 删除：O(logn)

#### 插入：
- 定位插入位置
  - 如果当前节点是空的（即节点为 nullptr），在此位置创建新节点。
  - 如果新节点的值小于当前节点的值，继续在当前节点的左子树中寻找插入位置。
  - 如果新节点的值大于当前节点的值，继续在当前节点的右子树中寻找插入位置。
- 创建新节点
  - 创建一个新的 TreeNode 实例，将给定的值赋给这个节点。新节点的左右子节点指针初始化为 nullptr。
- 插入新节点
  - 一旦找到了插入位置（找到一个 nullptr 指针位置），将新节点放在这个位置上。同时确保父节点的相应子节点链接指向新插入的节点（**递归**）。

#### 搜索：
- 开始于根节点
  - 搜索始终从二叉搜索树的根节点开始。
- 比较节点值
  - 如果要搜索的值与当前节点的值相等，搜索成功，返回该节点或 true。
  - 如果要搜索的值小于当前节点的值，转到该节点的左子节点。
  - 如果要搜索的值大于当前节点的值，转到该节点的右子节点。

#### 删除：
一旦找到目标节点，根据其子节点的数量，考虑以下三种情况：
- 无子节点（叶子节点）：
  - 直接删除这个节点，将其父节点指向它的指针设置为 nullptr。
- 一个子节点：
  - 将这个节点的父节点指向它的指针重定向到它的子节点。
  - 删除该节点。
- 两个子节点：
  - 找到要删除节点的右子树中的最小节点，即该子树的最左节点（或左子树的最大节点，即最右节点）。这个节点被称为继承者（successor）。
  - 将继承者的值复制到当前要删除的节点中。
  - 删除原继承者节点，因为其值已经被移动。对该继承者节点进行前两种删除操作，因为继承者没有左子树（如果是右子树的最小节点）。

#### 遍历二叉搜索树
- 中序遍历（In-order Traversal）
  - 首先访问左子树，然后访问根节点，最后访问右子树。对于二叉搜索树，中序遍历输出的节点顺序是从小到大的有序序列。
- 前序遍历（Pre-order Traversal）
  - 首先访问根节点，然后访问左子树，最后访问右子树。这种遍历方法在复制二叉树时特别有用，因为它从根节点开始复制。
- 后序遍历（Post-order Traversal）
  - 后序遍历首先访问左子树，然后访问右子树，最后访问根节点。这种遍历方法在递归删除或释放二叉树的资源时非常有用，因为它确保在删除根节点之前，先删除了子节点。

### 最大/最小堆(Max/Min Heap)
- 堆是一种特殊的树形数据结构，其中每个节点的值都必须大于等于（最大堆）或小于等于（最小堆）其子节点的值。
- 堆是一个完全二叉树，通常用数组来实现。
- 堆的根节点是数组的第一个元素，即索引为 0 的元素。
- 假设父节点的索引为 i，则左子节点的索引为 2i + 1，右子节点的索引为 2i + 2。
- 假设子节点的索引为 i，则父子节点的索引为(i-1)/2
- 堆的基本操作：
  - 插入（Insertion）：O(logn)
  - 删除（Deletion）：O(logn)
  - 查找最大/最小值（Find Max/Min）：O(1)
- 堆的应用：
  - 堆排序（Heap Sort）
  - 优先队列（Priority Queue）
  - 图算法（Dijkstra 算法、最小生成树算法）
  