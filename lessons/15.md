### 树(tree)
树，用来模拟具有树状结构性质的数据集合。它是由n（n>0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：

- 每个节点都只有有限个子节点或无子节点；
- 没有父节点的节点称为根节点；
- 每一个非根节点有且只有一个父节点；
- 除了根节点外，每个子节点可以分为多个不相交的子树；
- 树里面没有环路(cycle)

### 二叉树(Binary tree)
二叉树是每个节点最多只有两个分支（即不存在分支度大于2的节点）的树结构

### 二叉搜索树(Binary search tree)
#### 性质：
- 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；
- 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；
- 任意节点的左、右子树也分别为二叉查找树；
- 其中，左子树中最大节点（前继）和右子树中的最小节点（后继）被称为继承者（successor）
#### 时间复杂度：
- 搜索：O(logn)
- 插入：O(logn)
- 删除：O(logn)

#### 插入：
- 定位插入位置
  - 如果当前节点是空的（即节点为 nullptr），在此位置创建新节点。
  - 如果新节点的值小于当前节点的值，继续在当前节点的左子树中寻找插入位置。
  - 如果新节点的值大于当前节点的值，继续在当前节点的右子树中寻找插入位置。
- 创建新节点
  - 创建一个新的 TreeNode 实例，将给定的值赋给这个节点。新节点的左右子节点指针初始化为 nullptr。
- 插入新节点
  - 一旦找到了插入位置（找到一个 nullptr 指针位置），将新节点放在这个位置上。同时确保父节点的相应子节点链接指向新插入的节点（**递归**）。

#### 搜索：
- 开始于根节点
  - 搜索始终从二叉搜索树的根节点开始。
- 比较节点值
  - 如果要搜索的值与当前节点的值相等，搜索成功，返回该节点或 true。
  - 如果要搜索的值小于当前节点的值，转到该节点的左子节点。
  - 如果要搜索的值大于当前节点的值，转到该节点的右子节点。

#### 删除：
一旦找到目标节点，根据其子节点的数量，考虑以下三种情况：
- 无子节点（叶子节点）：
  - 直接删除这个节点，将其父节点指向它的指针设置为 nullptr。
- 一个子节点：
  - 将这个节点的父节点指向它的指针重定向到它的子节点。
  - 删除该节点。
- 两个子节点：
  - 找到要删除节点的右子树中的最小节点，即该子树的最左节点（或左子树的最大节点，即最右节点）。这个节点被称为继承者（successor）。
  - 将继承者的值复制到当前要删除的节点中。
  - 删除原继承者节点，因为其值已经被移动。对该继承者节点进行前两种删除操作，因为继承者没有左子树（如果是右子树的最小节点）。

#### 遍历二叉搜索树
- 中序遍历（In-order Traversal）
  - 首先访问左子树，然后访问根节点，最后访问右子树。对于二叉搜索树，中序遍历输出的节点顺序是从小到大的有序序列。
- 前序遍历（Pre-order Traversal）
  - 首先访问根节点，然后访问左子树，最后访问右子树。这种遍历方法在复制二叉树时特别有用，因为它从根节点开始复制。
- 后序遍历（Post-order Traversal）
  - 后序遍历首先访问左子树，然后访问右子树，最后访问根节点。这种遍历方法在递归删除或释放二叉树的资源时非常有用，因为它确保在删除根节点之前，先删除了子节点。